## Call-Site

To understand this binding, we have to understand call-site, which is a location in code where a function is called(not where it's declared, that's the lexcial scope to find variable's value)

## Followed Rules

### Default Binding - Standalone Function Invocation

**This** is binding to global variable, while this is undefined in **strict mode**

```javascript
function foo() {
  var a = "foo";
  function bar() {
    console.log(this.a); // global
    console.log("lexical scope: ", a); // foo
  }
  bar();
}
var a = "global";
foo();
```

```javascript
function foo() {
  var a = "foo";
  bar();
}
function bar() {
  console.log(this.a); // global
  console.log("lexical scope: ", a); // global
}
var a = "global";
foo();
```

### Implicit Binding

The object variable owns or contains the function reference, when call a function inside object, we use object.fn(), this is binding at object. Only the top/last level of object property reference chain matters to the call-site.

**Implicit lost**

Implicit lost this which means it fall back to the default binding of either the global object or undefined, depending on strict mode. This always happen as a reference to make a call includes in callback function such as setTimeout. Actually we can fix this with explict binding.

```javascript
const obj = {
  foo: () => {},
};
const bar = obj.foo;
bar(); // this -> global
```

```javascript
function foo() {
  console.log(this.a);
}
function doFoo(fn) {
  // `fn` is just another reference to `foo`
  fn(); // <-- call-site!
}
var obj = {
  a: 2,
  foo: foo,
};
var a = "oops, global"; // `a` also property on global object
doFoo(obj.foo); // "oops, global"
```

## Explicit Binding

### Call() Apply() methods

They both take, as their first parameter, an object to use for this, and then invoke the function with this.**It still cannot handle losing this binding**

### Hard Binding

```javascript
function foo() {
  console.log(this.a);
}
var a = "global";
const obj = {
  a: "object",
};
const bar = function () {
  foo.call(obj);
};
setTimeout(bar, 0); // "object"
bar.call(window); // "object"
```

But it still dosen't help with losing this binding.

### The Solution Is Bind Function

No matter how you later invoke the function bar, it always manually invoke foo with obj. This binding is both explicit and strong, so we call it **hard binding**.

```javascript
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

// simple `bind` helper
function bind(fn, obj) {
  return function () {
    return fn.apply(obj, arguments);
  };
}

var obj = {
  a: 2,
};

var bar = bind(foo, obj);

var b = bar(3); // 2 3
console.log(b); // 5
```

```javascript
function bind(fn, context, ...boundArgs) {
  function boundFunction(...args) {
    if (this instanceof boundFunction) {
      return new fn(...[...boundArgs, ...args]);
    }
    return fn.apply(context, [...boundArgs, ...args]);
  }
  boundFunction.prototype = Object.create(fn.prototype);
  return boundFunction;
}
```

### Bind Apply and Call

Key Conditions for Choosing
| Condition | Use bind | Use apply | Use call |
| :---------------------------------- | :------: | :--------: | :----: |
| Need a reusable function? | ✅ Yes | ❌ No | ❌ No |
| Fixed this for a callback? | ✅ Yes | ❌ No | ❌ No |
| Dynamic arguments (array-like)? | ❌ No | ✅ Yes | ❌ No |
| Static arguments (specific number)? | ❌ No | ❌ No | ✅ Yes |
| Borrowing a function? | ❌ No | ✅ Yes | ✅ Yes |

### New Binding

In class-oriented, constructors are just functions that happen to be called with the new operator in front of them. They are not attached to classes, nor are they instantiating a class. They are not even special types of functions. They're just regular functions that are, in essence, hijacked by the use of new in their invocation.

## What Happens During a new Call?

1. Create a new object:

```javascript
var obj = {};
```

2. Link the new object to the prototype

```javascript
obj.__proto__ = Foo.prototype;
```

3. Set "this" to the new object

```javascript
    this = obj
```

4. Execute the Fuction body
5. Return the object
